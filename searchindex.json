{"categories":[{"title":"Leecode","uri":"https://AIMHEctor.github.io/categories/leecode/"},{"title":"网络编程","uri":"https://AIMHEctor.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"posts":[{"content":"题目描述：\n有一个二维矩阵 A 其中每个元素的值为 0 或 1 。\n移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。\n在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。\n返回尽可能高的分数。\n 示例：\n输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]] 输出：39  解释：\n转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]] 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39  思路：\n 首先判断第一列是否都为1，如果元素不为1，则反转相应的行。然后从第二列开始遍历，判断每一列1的个数是否超过总数的一半，如果不超过，则反转相应的列，同时将结果累加。\n代码：\nclass Solution { public: int matrixScore(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; A) { if(A.empty()) return 0; int cos = A.size(); int row = A[0].size(); for(int i=0; i\u0026lt;cos; i++){ if(A[i][0] == 0){ int dex=0; while(dex \u0026lt; row){ A[i][dex] ^= 1; //对元素进行异或运算，1^1 = 0 ; 0^1 = 1 dex++; } } } int sum = cos * pow(2, row - 1); //记录第一列的和 for(int i=1; i\u0026lt;row; i++){ int count = 0; for(int j=0; j\u0026lt;cos; j++){ if(A[j][i] == 1) count ++; } if(count \u0026lt;= cos/2) count = cos - count; // 判断1的个数是否超过总行数的一半 sum += count * pow(2, row - i - 1); //计算当前列的和并进行累加 } return sum; } };  ","id":0,"section":"posts","summary":"题目描述： 有一个二维矩阵 A 其中每个元素的值为 0 或 1 。 移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为","tags":["Leecode"],"title":"861. 翻转矩阵后的得分","uri":"https://AIMHEctor.github.io/2020/05/861/","year":"2020"},{"content":"题目描述：\n如果我们交换字符串 X 中的两个不同位置的字母，使得它和字符串 Y 相等，那么称 X 和 Y 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。\n例如，\u0026ldquo;tars\u0026rdquo; 和 \u0026ldquo;rats\u0026rdquo; 是相似的 (交换 0 与 2 的位置)； \u0026ldquo;rats\u0026rdquo; 和 \u0026ldquo;arts\u0026rdquo; 也是相似的，但是 \u0026ldquo;star\u0026rdquo; 不与 \u0026ldquo;tars\u0026rdquo;，\u0026ldquo;rats\u0026rdquo;，或 \u0026ldquo;arts\u0026rdquo; 相似。\n总之，它们通过相似性形成了两个关联组：{\u0026ldquo;tars\u0026rdquo;, \u0026ldquo;rats\u0026rdquo;, \u0026ldquo;arts\u0026rdquo;} 和 {\u0026ldquo;star\u0026rdquo;}。注意，\u0026ldquo;tars\u0026rdquo; 和 \u0026ldquo;arts\u0026rdquo; 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。\n我们给出了一个不包含重复的字符串列表 A。列表中的每个字符串都是 A 中其它所有字符串的一个字母异位词。请问 A 中有多少个相似字符串组？\n输入：[\u0026ldquo;tars\u0026rdquo;,\u0026ldquo;rats\u0026rdquo;,\u0026ldquo;arts\u0026rdquo;,\u0026ldquo;star\u0026rdquo;]\n输出：2\n思路：\nconst int maxn = 1e4+10; class Solution { public: vector\u0026lt;int\u0026gt; g[maxn]; bool solve(string \u0026amp;s1,string \u0026amp;s2){ int diff = 0; for(int i=0; i\u0026lt;s1.length(); i++){ if(s1[i] != s2[i]) diff++; if(diff\u0026gt;2) return false; } return true; } void dfs(int i,vector\u0026lt;int\u0026gt;\u0026amp;vis){ vis[i]=1; for(auto v:g[i]){ if(!vis[v]){ dfs(v,vis); } } } int numSimilarGroups(vector\u0026lt;string\u0026gt;\u0026amp; A) { int n = A.size(); for(int i=0; i\u0026lt;n; i++){ for(int j=1; j\u0026lt;n; j++){ if(solve(A[i],A[j])){ g[i].push_back(j); g[j].push_back(i); } } } int count = 0; vector\u0026lt;int\u0026gt; vis(n+1,0); for(int i =0; i\u0026lt;n; i++){ if(!vis[i]){ count++; dfs(i,vis); } } return count; } };  ","id":1,"section":"posts","summary":"题目描述： 如果我们交换字符串 X 中的两个不同位置的字母，使得它和字符串 Y 相等，那么称 X 和 Y 两个字符串相似。如果这两个字符串本身是相等的，那它们","tags":["Leecode"],"title":"839. 相似字符串组","uri":"https://AIMHEctor.github.io/2020/05/839/","year":"2020"},{"content":"阻塞 / 非阻塞 VS 同步 / 异步  第一种是阻塞 I/O。阻塞 I/O 发起的 read 请求，线程会被挂起，一直等到内核数据准备好，并把数据从内核区域拷贝到应用程序的缓冲区中，当拷贝过程完成，read 请求调用才返回。接下来，应用程序就可以对缓冲区的数据进行数据解析。\n 第二种是非阻塞 I/O。非阻塞的 read 请求在数据未准备好的情况下立即返回，应用程序可以不断轮询内核，直到数据准备好，内核将数据拷贝到应用程序缓冲，并完成这次 read 调用。注意，这里最后一次 read 调用，获取数据的过程，是一个同步的过程。这里的同步指的是内核区域的数据拷贝到缓存区这个过程。\n 每次让应用程序去轮询内核的 I/O 是否准备好，是一个不经济的做法，因为在轮询的过程中应用进程啥也不能干。于是，像 select、poll 这样的 I/O 多路复用技术就隆重登场了。通过 I/O 事件分发，当内核数据准备好时，再通知应用程序进行操作。这个做法大大改善了应用进程对 CPU 的利用率，在没有被通知的情况下，应用进程可以使用 CPU 做其他的事情。注意，这里 read 调用，获取数据的过程，也是一个同步的过程。\n 第一种阻塞 I/O 我想你已经比较了解了，在阻塞 I/O 的情况下，应用程序会被挂起，直到获取数据。第二种非阻塞 I/O 和第三种基于非阻塞 I/O 的多路复用技术，获取数据的操作不会被阻塞。\n 无论是第一种阻塞 I/O，还是第二种非阻塞 I/O，第三种基于非阻塞 I/O 的多路复用都是同步调用技术。为什么这么说呢？因为同步调用、异步调用的说法，是对于获取数据的过程而言的，前面几种最后获取数据的 read 操作调用，都是同步的，在 read 调用时，内核将数据从内核空间拷贝到应用程序空间，这个过程是在 read 函数中同步进行的，如果内核实现的拷贝效率很差，read 调用就会在这个同步过程中消耗比较长的时间。\n 而真正的异步调用则不用担心这个问题，我们接下来就来介绍第四种 I/O 技术，当我们发起 aio_read 之后，就立即返回，内核自动将数据从内核空间拷贝到应用程序空间，这个拷贝过程是异步的，内核自动完成的，和前面的同步操作不一样，应用程序并不需要主动发起拷贝动作。\n","id":2,"section":"posts","summary":"阻塞 / 非阻塞 VS 同步 / 异步 第一种是阻塞 I/O。阻塞 I/O 发起的 read 请求，线程会被挂起，一直等到内核数据准备好，并把数据从内核区域拷贝到应用程序的缓冲","tags":["网络编程"],"title":"网络IO模型","uri":"https://AIMHEctor.github.io/2020/05/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B_01/","year":"2020"},{"content":"1.new 与 malloc\n new 是C++的操作符，malloc是C的标准库函数 new会调用构造函数，而malloc()不会 new返回指定类型的指针，而malloc()返回void* new会自动计算需要分配的空间，而malloc()需要手工计算字节数。 new可以被重载，而malloc()不能。  使用new时实际执行的三步操作：\n 调用::operator new 配置内存 调用Foo()构造函数构造对象并传入初始值 返回一个指向该对象的指针  2.内存溢出和内存泄漏 内存溢出，指的是系统不能再分配出你所需要的空间。\n内存泄漏，指的是没有释放掉已经不再使用的内存\n内存泄漏的类型\n 堆内存泄漏  程序运行中根据需要从堆内存中分配一块内存，并且没有释放掉。   系统资源泄漏  常见的内存溢出\n 内存分配未成功，却使用了它。 内存分配虽然成功，但是尚未初始化就引用它 。 内存分配成功并且已经初始化，但操作越过了内存的边界。 忘记了释放内存，造成内存泄露。  2.智能指针(将普通的指针封装为一个栈对象)\n智能指针可以防止忘记调用delete释放内存，以及多次释放同一个指针所造成的程序崩溃。实现了资源自动释放。\n unique_ptr  生命周期：从指针创建开始到离开作用域。 如果没有多线程共享资源，则使用unique_ptr   shared_ptr  智能指针是模版类，使用make_shared函数来初始化 ，不能将指针直接复制给一个智能指针 get函数获取原始指针 使用引用计数实现多个智能指针同时指向一个对象 拷贝和赋值，拷贝使得对象的引用计数加一，赋值使得引用计数减一，指向后来的对象。 循环引用，会导致堆内存无法正确释放导致内存泄漏。   weak_ptr  不控制所指对象的生命周期，指向一个由shared_ptr管理的对象 使用shared_ptr来初始化它 auto p = make_shared42 ; weak_ptrwp(p)//wp弱共享p,p的引用计数不变。 expired()观测引用计数，若为true则引用计数为0；lock(),获取一个可用的shared_ptr对象，从而操作资源，若引用计数为0则返回一个存储空指针的shared_ptr    内部实现\nhttps://blog.csdn.net/gammag/article/details/88655744\n3. 虚函数\n虚函数的作用 C++中的虚函数的作用主要是实现了多态的机制。基类定义虚函数，子类可以重写该函数；在派生类中对基类定义的虚函数进行重写时，需要在派生类中声明该方法为虚方法。\n当子类重新定义了父类的虚函数后，当父类的指针指向子类对象的地址时，[即B b; A a = \u0026amp;b;] 父类指针根据赋给它的不同子类指针，动态的调用子类的该函数，而不是父类的函数（如果不使用virtual方法，请看后面★*），且这样的函数调用发生在运行阶段，而不是发生在编译阶段，称为动态联编。而函数的重载可以认为是多态，只不过是静态的。注意，非虚函数静态联编，效率要比虚函数高，但是不具备动态联编能力。\n虚函数的实现机制\n虚函数表\n1、当类中存在虚函数里.则编译器会在编译期自动的给该类生成一个函数表，并在所有该类的对像中放入一个隐式变量vptr,该变量是一个指针变量，它的值指向那个类中的由编译器生成的虚函数表.\n2、每个类自己的虚函数入口都在这张表中维护，调用方法的时候会隐式的传入一个this指针，然后系统会根据this指针找到对应的vptr,进而找到对应的虚函数表，找到真正方法的地址，然后才去调用这个方法，这可以叫动态绑定。\n3、虚函数表存放重写的虚函数，当基类的指针指向派生类的对象时，调用虚函数时都会根据vptr来选择虚函数，而基类的虚函数在派生类里已经被改写或者说已经不存在了，所以也就只能调用派生类的虚函数版本了.\n实现机制\nhttps://www.cnblogs.com/malecrab/p/5572730.html\nhttps://www.cnblogs.com/yinbiao/p/11603618.html\nvptr问题\nhttps://www.cnblogs.com/yangguang-it/p/6547314.html\n析构函数可以是虚函数吗\n如果基类会被继承，则需要将析构函数设置为虚函数。\n基类指针可以指向派生类的对象（多态性），如果删除该指针delete[] p;就会调用该指针指向的派生类析构函数，而派生类的析构函数又会自动调用基类的析构函数，这样整个派生类的对象完全被释放。如果析构函数不被声明为虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类的析构函数，这样就会造成派生类对象析构不完全。所以，将析构函数声明为虚函数是十分必要的。\n构造函数可以调用虚函数\n构造函数是可以调用虚函数的，例子 https://paste.ubuntu.com/p/qwGZRNjj2m/\n总结：是进行静态绑定，首先构造父类构造函数，虚函数也调用父类的，然后调用子类构造函数，虚函数也调用子类的。\n纯虚函数和虚函数\n有纯虚函数的类为抽象类。 纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。\n在基类中实现纯虚函数的方法是在函数原型后加“=0” virtual void function()=0\n详情见：https://www.cnblogs.com/steven66/p/5013695.html。\n4.面向对象理解\n详情见：https://www.cnblogs.com/ycg0808/p/5479213.html。\n四大特征：继承、多态、封装、抽象。\n继承：子类继承父类的特征和行为。子类可以有父类的方法，属性（非private）。子类也可以对父类进行扩展，也可以重写父类的方法。缺点就是提高了代码之间的耦合。final可以修饰类，方法，属性。修饰的类不能继承，修饰的方法不能重写，修饰的属性不能修改。\n多态：多态就是不同类的对象，对同一消息做出不同响应就叫多态。\n封装：封装就是把过程和数据包围起来，对数据的访问只能通过特定的界面。能降低耦合性。\n抽象：分为过程抽象和数据抽象。\n详情见：https://www.cnblogs.com/msn-z/p/7802576.html。\n5.内存模型\n栈（局部变量，编译时分配） 堆（动态存储区）（new程序时分配） 静态存储区（所有的静态/全局变量） 数据区 代码区\nC分为4个区：堆，栈，静态全局变量区，常量区。 C++内存分为5个区：\n1：栈区（stack）-由编译器自动分配释放，存放函数参数值，局部变量等。其操作类似于数据机构中栈。\n2：堆区（heap）-一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中堆是两回事，分配方式类似于链表。\n3：全局区（静态区static）-全局变量和静态变量存取释放在一快，初始化全局变量和静态变量在一块区域。未初始化全局变量和未初始化静态变量在相邻另一块区域，程序结束后由系统释放。\n4：文字常量区（coment）-常量字符串就是放在这里。程序结束后由系统释放。\n5： 程序代码区（code）- 存放函数二进制代码 详情见：https://www.cnblogs.com/Stultz-Lee/p/6751522.html。\n5.常见设计模式\n详细链接\nhttps://blog.csdn.net/u010993820/article/details/80968933\n单例模式详解\nhttps://blog.csdn.net/zhanghuaichao/article/details/79459130\n6.inline\nC++ 用 inline 关键字较好地解决了函数调用开销的问题。\n增加了 inline 关键字的函数称为“内联函数”。内联函数和普通函数的区别在于：当编译器处理调用内联函数的语句时，不会将该语句编译成函数调用的指令，而是直接将整个函数体的代码插人调用语句处，就像整个函数体在调用处被重写了一遍一样。\n有了内联函数，就能像调用一个函数那样方便地重复使用一段代码，而不需要付出执行函数调用的额外开销。很显然，使用内联函数会使最终可执行程序的体积增加。以时间换取空间，或增加空间消耗来节省时间，这是计算机学科中常用的方法。\n内联函数中的代码应该只是很简单、执行很快的几条语句。若比较复杂则不会判为内联函数。\nhttp://c.biancheng.net/view/199.html\nSTL 源码内容 1.STL的vector底层扩容\nvector实际上就是一个动态数组，底层是一段连续的线性内存空间。使用三个迭代器表示（指针）\n当大小和容量相等时，vector就需要扩容，此时需要三个步骤：\n 弃用现在的内存空间，申请一个两倍（1.5倍）大小的新的内存空间。 将旧的内存空间中的数据写入 将旧内存空间释放  2.STL的map、set底层数据结构\n查询的时间复杂度为O(lgn);空间复杂度为O(n); 底层数据结构都为红黑树\n红黑树底层提供两种insert操作：insert_unique() /insert_equal()\n红黑树的实现：五个模版（key value keyofvalue compare alloc）\nset\n set/multiset元素的value和key合一：value就是key 不可以通过迭代器修改元素（set的iterator为红黑树的const 迭代器，从而避免通过迭代器改变元素） set的操作都转给底层的模版进行操作，从技术的角度来说，set是一种container adapter（容器适配器，类似queue）  map\n map中key不可以修改，value可以。value和key组成value 红黑树的selectlst（select first）获取key （gcc） 实现第一条：把value包装成pair，其中key设置为const 独特的operator[],如果key不存在，lower_bound()找到合适的位置，并创建一个key插入红黑树  3.容器hashtable\n  空间足够时，直接按照编号插入\n  空间不足时，编号取余（空间大小）\n  如果发生冲突则通过链表串起来，但是如果串联的个数大于buckets vector（篮子的数量）则进行散列（篮子变为两倍附近的素数，53-\u0026gt;97）\n  hashtable的实现：value、key、HashFcn（将放入的东西映射为编号）、ExtractKey（如何提取key）、EqualKey（定义key相等）\n  ","id":3,"section":"posts","summary":"1.new 与 malloc new 是C++的操作符，malloc是C的标准库函数 new会调用构造函数，而malloc()不会 new返回指定类型的指针，而malloc(","tags":["C++"],"title":"C++基础问题总结","uri":"https://AIMHEctor.github.io/2020/04/c-/","year":"2020"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\n Create a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so:\n  {{ if or .Params.math .Site.Params.math }} {{ partial \u0026quot;math.html\u0026quot; . }} {{ end }}   To enable KaTex globally set the parameter math to true in a project's configuration To enable KaTex on a per page basis include the parameter math: true in content files.  Note: Use the online reference of Supported TeX Functions Examples Inline math: \\( \\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887… \\)\nBlock math:\n\\[ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } \\]\n","id":4,"section":"posts","summary":"\u003cp\u003eMathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\u003c/p\u003e","tags":null,"title":"Math Typesetting","uri":"https://AIMHEctor.github.io/2019/03/math-typesetting/","year":"2019"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site’s configuration and then you can type emoji shorthand codes directly in content files; e.g.\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\n N.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n.emoji { font-family: Apple Color Emoji,Segoe UI Emoji,NotoColorEmoji,Segoe UI Symbol,Android Emoji,EmojiSymbols; }","id":5,"section":"posts","summary":"\u003cp\u003eEmoji can be enabled in a Hugo project in a number of ways.\u003c/p\u003e","tags":["emoji"],"title":"Emoji Support","uri":"https://AIMHEctor.github.io/2019/03/emoji-support/","year":"2019"}],"tags":[{"title":"C++","uri":"https://AIMHEctor.github.io/tags/c++/"},{"title":"emoji","uri":"https://AIMHEctor.github.io/tags/emoji/"},{"title":"Leecode","uri":"https://AIMHEctor.github.io/tags/leecode/"},{"title":"网络编程","uri":"https://AIMHEctor.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]}