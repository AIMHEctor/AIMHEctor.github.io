{"categories":[{"title":"Leetcode","uri":"https://aimhector.github.io/categories/leetcode/"},{"title":"网络编程","uri":"https://aimhector.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"posts":[{"content":" 定义一个简单的图结构，完成对一个有向图的遍历： a) 当无环的时候，输出拓扑遍历的顺序， b) 当有环时，输出空（无法遍历）  eg\n a-b-c-d, a b c d a-b-c-a, 空 a-b a-c b-d c-d, a b c d或a c b d均可  #include \u0026lt;stack\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include\u0026lt;string.h\u0026gt; using namespace std; const int MAXVEX = 100; struct EdgeNode { int adjvex; //邻接点域 //int weight; //存储权值 EdgeNode* next; }; struct VNode { char data; //顶点域 EdgeNode* first; //边表头指针 }AdjList[MAXVEX]; // typedef struct{ // AdjList adjList; // 邻接表 // int vexnum,arcnum; // }ALGraph; //以邻接表存储的图类型 int inCount[MAXVEX]; //记录入度节点数 void creatLink(int \u0026amp;numNode){ int numLink = 0; EdgeNode* ptr; cout\u0026lt;\u0026lt;\u0026quot;输入节点数：\u0026quot;\u0026lt;\u0026lt;endl; cin\u0026gt;\u0026gt;numNode; cout\u0026lt;\u0026lt;endl; memset(inCount,0,sizeof(int)*(numNode+1)); for(int i=1; i\u0026lt;=numNode; i++){ AdjList[i].first = 0; cout\u0026lt;\u0026lt;\u0026quot;输入节点data域：\u0026quot;\u0026lt;\u0026lt;endl; cin\u0026gt;\u0026gt;AdjList[i].data; cout\u0026lt;\u0026lt;\u0026quot;输入连接数量：\u0026quot;\u0026lt;\u0026lt;endl; cin\u0026gt;\u0026gt;numLink; for(int j=0; j\u0026lt;numLink; j++){ ptr = new EdgeNode; cout\u0026lt;\u0026lt;\u0026quot;输入节点编号：\u0026quot;\u0026lt;\u0026lt;endl; cin\u0026gt;\u0026gt;ptr-\u0026gt;adjvex; ++inCount[ptr-\u0026gt;adjvex]; ptr-\u0026gt;next = AdjList[i].first; //头插法 AdjList[i].first = ptr; } } } vector\u0026lt;char\u0026gt; TopoSort(int\u0026amp; numNode){ vector\u0026lt;char\u0026gt; vec; vector\u0026lt;char\u0026gt; nul={0}; stack\u0026lt;int\u0026gt; stk; EdgeNode* p = 0; int outNum = 0; for(int i =1; i\u0026lt;=numNode; i++){ if(inCount[i]==0) stk.push(i); } while(!stk.empty()){ int v = stk.top(); stk.pop(); vec.push_back(AdjList[v].data); inCount[v] = -1; ++outNum; p = AdjList[v].first; while(p != nullptr){ --inCount[p-\u0026gt;adjvex]; if(inCount[p-\u0026gt;adjvex] == 0) stk.push(p-\u0026gt;adjvex); p = p-\u0026gt;next; } } if(outNum \u0026lt; numNode) return nul; //返回空vector else return vec; } int main(){ vector\u0026lt;char\u0026gt; res; int num = 0; creatLink(num); res = TopoSort(num); for(int i=0; i\u0026lt;res.size(); i++){ cout\u0026lt;\u0026lt;res[i]\u0026lt;\u0026lt;\u0026quot; \u0026quot;; } return 0; }  ","id":0,"section":"posts","summary":"定义一个简单的图结构，完成对一个有向图的遍历： a) 当无环的时候，输出拓扑遍历的顺序， b) 当有环时，输出空（无法遍历） eg a-b-c-d, a b c d a-b-c-a, 空 a-b a-c b-d c-d, a b","tags":["Leetcode"],"title":"判断图结构是否有环","uri":"https://aimhector.github.io/2020/05/%E5%88%A4%E6%96%AD%E5%9B%BE%E7%BB%93%E6%9E%84%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF/","year":"2020"},{"content":"编译阶段编程 ","id":1,"section":"posts","summary":"编译阶段编程","tags":["C++"],"title":"属性和静态断言","uri":"https://aimhector.github.io/2020/05/%E5%B1%9E%E6%80%A7%E5%92%8C%E9%9D%99%E6%80%81%E6%96%AD%E8%A8%80/","year":"2020"},{"content":"项目梳理 1.使用epoll边缘触发的I/O多路复用技术，非阻塞IO\nQ1：为什么使用epoll？\nepoll维护了一个红黑树，使用epoll可以避免用户态到内核态频繁的数据拷贝和内存分配。\n而且epoll维护了一个链表来记录就绪事件，每当有事件发生，通过注册的回调函数将事件加入到就绪列表中，返回时只需要遍历就绪链表即可，而无需对内核的描述字进行遍历。\nQ2:边缘触发和水平触发的区别？\n在水平触发机制中，只要有数据没有被获取，内核就会不断通知你。\n而边缘触发机制只有在状态发生变化时，触发一个事件，并不会传递同样的事件。所以边缘触发的效率更高。\nQ3:阻塞IO/非阻塞IO\n阻塞IO发起请求后，线程会被挂起，直到处理完成返回数据。\n非阻塞IO发起请求后，数据在未准备好的情况下会立即返回，应用程序可以不断轮询内核直到数据准备好。\nIO多路复用，通过I/O事件分发，当内核数据准备完成就通知应用程序进行操作。\n2.使用线程池来处理请求，避免线程创建销毁的开销，基于reactor模式，主线程负责accept请求并以 Round Robin 的方式分发给其他 IO 线程。\n","id":2,"section":"posts","summary":"项目梳理 1.使用epoll边缘触发的I/O多路复用技术，非阻塞IO Q1：为什么使用epoll？ epoll维护了一个红黑树，使用epoll可以","tags":null,"title":"项目梳理","uri":"https://aimhector.github.io/2020/05/%E9%A1%B9%E7%9B%AE%E6%A2%B3%E7%90%86/","year":"2020"},{"content":"//快排单向扫描 void quickSort3(vector\u0026lt;int\u0026gt;\u0026amp; nums,int l , int r){ if(l \u0026lt; r){ int p = parition1(nums,l,r); quickSort3(nums,l,p-1); quickSort3(nums,p+1,r); } } int parition1(vector\u0026lt;int\u0026gt;\u0026amp; nums , int l , int r){ int p = nums[l]; int j = l+1; for(int i = l ; i \u0026lt; r ; ++i){ if(nums[i] \u0026lt; p){ swap(nums[i],nums[j++]); } } swap(nums[j],nums[r]); return j; } //快速排序 双向扫描 void quickSort2(vector\u0026lt;int\u0026gt;\u0026amp; nums,int low,int high){ if(low\u0026lt;high){ int q=parition(nums,low,high); quickSort2(nums,low,q-1); quickSort2(nums,q+1,high); } } int parition(vector\u0026lt;int\u0026gt;\u0026amp; nums , int low,int high){ int piv = nums[low]; int i = low+1; int j = high; while(true){ while(i \u0026lt;= j \u0026amp;\u0026amp; nums[i] \u0026lt;= piv) i++; while(i \u0026lt;= j \u0026amp;\u0026amp; nums[j] \u0026gt;= piv) j--; if(i \u0026gt;= j) break; int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; } nums[low] = nums[j]; nums[j] = piv; return j; }  ","id":3,"section":"posts","summary":"//快排单向扫描 void quickSort3(vector\u0026lt;int\u0026gt;\u0026amp; nums,int l , int r){ if(l \u0026lt; r){ int p = parition1(nums,l,r); quickSort3(nums,l,p-1); quickSort3(nums,p+1,r); } } int parition1(vector\u0026lt;int\u0026gt;\u0026amp; nums , int l , int r){ int p = nums[l]; int j = l+1; for(int i = l ; i \u0026lt; r ; ++i){ if(nums[i] \u0026lt; p){ swap(nums[i],nums[j++]); } } swap(nums[j],nums[r]); return j; } //快速排序 双","tags":["Leetcode"],"title":"快排","uri":"https://aimhector.github.io/2020/05/%E5%BF%AB%E6%8E%92/","year":"2020"},{"content":"102. 二叉树的层序遍历\n给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。\n示例： 二叉树：[3,9,20,null,null,15,7],\n 3 / \\ 9 20 / \\ 15 7  返回其层次遍历结果： [ [3], [9,20], [15,7] ]\n思路：广度优先遍历\n代码实现：\n/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode* root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; if(root == nullptr) return res; queue\u0026lt;TreeNode*\u0026gt; q; q.push(root); while(!q.empty()){ vector\u0026lt;int\u0026gt; vec; int len = q.size(); for(int i=0; i\u0026lt;len; i++){ TreeNode* tmp = q.front(); vec.push_back(tmp-\u0026gt;val); if(tmp-\u0026gt;left != nullptr) q.push(tmp-\u0026gt;left); if(tmp-\u0026gt;right != nullptr) q.push(tmp-\u0026gt;right); q.pop(); } res.push_back(vec); } return res; } };  二叉树之字形打印\n思路：增加一个bool变量，如果为true则对vector进行反转，每次变换bool值。\n代码实现：\nclass Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode* root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; if(root == nullptr) return res; queue\u0026lt;TreeNode*\u0026gt; q; bool change = false; q.push(root); while(!q.empty()){ vector\u0026lt;int\u0026gt; vec; int len = q.size(); for(int i=0; i\u0026lt;len; i++){ TreeNode* tmp = q.front(); vec.push_back(tmp-\u0026gt;val); if(tmp-\u0026gt;left != nullptr) q.push(tmp-\u0026gt;left); if(tmp-\u0026gt;right != nullptr) q.push(tmp-\u0026gt;right); q.pop(); } if(change) reverse(vec.begin(),vec.end()); change = !change; res.push_back(vec); } return res; } };  ","id":4,"section":"posts","summary":"102. 二叉树的层序遍历 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 示例： 二叉树：[3,9,20,nul","tags":["Leetcode"],"title":"二叉树层的层次遍历","uri":"https://aimhector.github.io/2020/05/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/","year":"2020"},{"content":"1.一个硬币，正面概率0.7，反面概率0.3，现在有一瓶水，怎么掷能让两个人公平的喝到水\n抛两次硬币，先正后反A喝到水，先反后正B喝到水。如果两次都为正或者都为反则重新抛硬币。\n2.54张扑克牌，平均分成3份，大小王在一份的概率\n解答1：\n54张牌分成3等份，共有M=(C54取18)(C36取18)(C18取18)种分法。\n其中大小王在同一份的分法有N=(C3取1)(C52取16)(C36取18)*(C18取18)种。\n因此所求概率为P=N / M=17/53。\n解答2：\n不妨记三份为A、B、C份。大小王之一肯定在某一份中，不妨假定在A份中，概率为1/3。然后A份只有17张牌中可能含有另一张王，而B份、C份则各有18张牌可能含有另一张王，因此A份中含有另一张王的概率是17/(17+18+18)=17/53。\n也因此可知，A份中同时含有大小王的概率为1/3 * 17/53。\n题目问的是出现在同一份中的概率，因此所求概率为3*(1/3 * 17/53)=17/53。\n3.两个人轮流抛硬币，先抛到正面的赢，问先抛的人赢的概率\n假设A先抛：\n第一轮，A赢：1/2；B赢：1/2*1/2=1/4\n第二轮，A赢：1/21/21/2=1/8；B赢：1/21/21/2*1/2=1/16\n可以看出A每一轮赢的概率为等比数列，公比为1/4\n所以A赢的概率应该为等比数列的和，求极限为2/3\n","id":5,"section":"posts","summary":"1.一个硬币，正面概率0.7，反面概率0.3，现在有一瓶水，怎么掷能让两个人公平的喝到水 抛两次硬币，先正后反A喝到水，先反后正B喝到水。如果","tags":null,"title":"概率问题（待更新）","uri":"https://aimhector.github.io/2020/05/%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98/","year":"2020"},{"content":"单例模式保证一个类只有一个实例，并提供了该实例的全局访问。\n实现一：饿汉式\nclass Singleton{ public: static Singleton* getInstance(){ //首先检查对象是否存在 if(m_instance == nullptr){ m_instance = new Singleton(); } return m_instance; } private: Singleton(){}; ~Singleton(){}; static Singleton* m_instance; //静态成员变量 }； Singleton* Singleton:m_instance = nullptr; //静态成员初始化  将构造函数设置为私有的，在第一次调用getInstance()的时候生成对象，然而这种写法在多线程的情况下树不安全的。\n如果线程A执行m_instance = new Singleton()未完成，此时m_instance = nullptr,而线程B也正在执行m_instance = new Singleton()，这就会产生两个对象，进而导致程序错误，发生内存泄漏。\n实现二：DCL（double-checked-locking）双锁检查\nSingleton* Singleton::getInstance(){ if(m_instance == nullptr){ lock(); if(m_instance == nullptr){ m_instance = new Singleton(); } unlock(); } return m_instance; }  这样子写看起来很好，只有在第一次必要的时候才会使用锁。然而却有一个漏洞，内存读写的乱序执行。\n执行new Singleton()时分为三个步骤执行：\n 分配类型对象所需的内存 在分配内存处构造Singleton对象。 把分配的内存的地址赋给指针m_instance.  在实际的执行中，2和3的执行顺序不确定。如果某线程按照132执行，当执行完3时，切换到另外一个线程new Singleton()由于m_instance 已经不是nullptr所以会直接返回得到一个对象，然而这个对象并没有被构造，BUG就此产生了。\n实现三：使用pthread_once函数\n声明: int pthread_once(pthread_once_t once_control, void (init_routine) (void))；\n功能: 本函数使用初值为PTHREAD_ONCE_INIT的once_control 变量保证init_routine()函数在本进程执行序列中仅执行一次。\nclass Singleton{ public: static Singleton* getInstance(){ phread_once(\u0026amp;ponce_, \u0026amp;Singleton::init); return m_instance; } private: Singleton(){}; ~Singleton(){}; static void init(){ m_instance = new Singleton(); } static pthread_once_t ponce_; static Singleton* m_instance; }； pthread_once_t Singleton::ponce_ = PTHREAD_ONCE_INIT; Singleton* Singleton::m_instance = nullptr;  能够保证线程安全，缺点是不能够跨平台。\n实现四：利用static线程安全 在c++11中局部静态变量不仅只会初始化一次，而且还是线程安全的。\nclass Singleton{ public: static Singleton\u0026amp; getInstance(){ static Singleton m_instance; return m_instance; // 返回的是引用 } private： Singleton(){}; ~Singleton(){}; }  ","id":6,"section":"posts","summary":"单例模式保证一个类只有一个实例，并提供了该实例的全局访问。 实现一：饿汉式 class Singleton{ public: static Singleton* getInstance(){ //首先检查对象是否存在 if(m_instance == nullptr){ m_instance = new Singleton(); } return m_instance; } private: Singleton(){}; ~Singleton(){}; static Singleton*","tags":["Leetcode"],"title":"单例模式","uri":"https://aimhector.github.io/2020/05/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","year":"2020"},{"content":"leetcode.113 路径总和2\n给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。\n说明: 叶子节点是指没有子节点的节点。\n示例: 给定如下二叉树，以及目标和 sum = 22，\n 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1  返回:\n[ [5,4,11,2], [5,8,4,5] ]  深度优先遍历（回溯法）代码实现：\n/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pathSum(TreeNode* root, int sum) { dfs(root, sum); return res; } void dfs(TreeNode* root, int sum){ if(!root) return; //终止条件 sum -= root-\u0026gt;val; tmp.push_back(root-\u0026gt;val); //判断如果root为根结点且和为sum则保存结果 if(!root-\u0026gt;left \u0026amp;\u0026amp; !root-\u0026gt;right \u0026amp;\u0026amp; sum == 0){ res.push_back(tmp); } else{ //深度优先遍历 dfs(root-\u0026gt;left, sum); dfs(root-\u0026gt;right, sum); } tmp.pop_back(); //不满足条件，进行回溯 sum += root-\u0026gt;val; } private: vector\u0026lt;int\u0026gt; tmp; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; };  leetcode.112 路径总和 给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。\n说明: 叶子节点是指没有子节点的节点。\n思路：利用递归，使用深度优先遍历整颗树，每次遍历sum减去当前节点值，如果该节点是叶子节点则判断sum是否为0，如果该节点不是叶子节点，则分别最左右子节点调用dfs。\n代码实现：\n/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool hasPathSum(TreeNode* root, int sum) { return dfs(root, sum); } bool dfs(TreeNode* root, int sum){ if(!root) return false ; sum -= root-\u0026gt;val; if(!root-\u0026gt;left \u0026amp;\u0026amp; !root-\u0026gt;right \u0026amp;\u0026amp; sum ==0) return true; return dfs(root-\u0026gt;left, sum) || dfs(root-\u0026gt;right, sum); } };  ","id":7,"section":"posts","summary":"leetcode.113 路径总和2 给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 说明: 叶子节点是指没有子节点的节点。 示例: 给","tags":["Leetcode"],"title":"二叉树路径","uri":"https://aimhector.github.io/2020/05/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B7%AF%E5%BE%84/","year":"2020"},{"content":"买卖股票问题有多种变体，在一些变体中需要考虑动态规划的思路才能够更好的解决。题目大意是给定一个数组，第i 个元素即股票在第i 天的价格，求解通过买入卖出的操作所能够达到的最大收益。\n共有如下四个变形：\n121. 买卖股票的最佳时机(只能够买卖一次) 122. 买卖股票的最佳时机 II（不限制买卖次数） 123. 买卖股票的最佳时机 III（最多可以买卖两次） 188. 买卖股票的最佳时机 IV（最多可以买卖K次）  首先我们从最简单的只能够买卖一次开始分析。\nleecode121思路：采用一次遍历即可解决，每次遍历通过max和min函数分别计算当前的最大收益和到此为止的最低股价。\n代码实现：\nclass Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { if(prices.empty()) return 0; int minprice = INT_MAX, res = 0; for (int price: prices) { res = max(res, price - minprice); minprice = min(price, minprice); } return res; } };  我们再来看一下它的变体，不限制买入和卖出的次数Leetcode122。既然不限制它的买入和卖出的次数，那么我们只需要计算每个分段增量的和即可。即，从第二个元素开始遍历，每次判断它是否大于前一个元素，如果大于则将结果加上它们的差值，否则continue。\n代码实现：\nclass Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { if(prices.empty()) return 0; int res = 0; for(int i=1; i\u0026lt;prices.size(); i++){ if(prices[i] \u0026gt;= prices[i-1]){ res += prices[i] - prices[i-1]; } else continue; } return res; } };  好了，我们现在把条件变为最多允许两次交易（买入和卖出），这使得问题变得不那么容易。我们首先按照常规思路分析，如果考虑达到高点时就卖出，由于次数限制，不一定得到最大收益。\n例如：\n1 6 2 10 3 9  如果只考虑高点卖出，则收益分别为5，8，6，又因为只能交易两次，则最大收益为8+6=14。这显然存在问题，如果我们第一次交易在1买入而在10卖出则会达到最大交易9+6=15。\n所以这个问题不能够简单考虑而应该引入动态规划。我们首先来考虑一下它的状态转移方程应该是怎样的，动态规划实际上就是用状态进行穷举，对于这道题而言一共有两个状态持有股票和不持有股票，我们需要找出每个状态对应的选择。\n对应的状态转移方程：\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) //max(昨天未持有，昨天持有但是今天卖掉了) //其中i表示天数、k表示交易次数、0表示状态不持有股票 dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) //max(昨天持有股票， 昨天未持有今天买入)  明确了状态转移方程后，我们还需要一步，定义最简单的情况。\ndp[-1][k][0] = 0 解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。 dp[-1][k][1] = -infinity 解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。 dp[i][0][0] = 0 解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润是 0 。 dp[i][0][1] = -infinity 解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。  此时我们在回来看第一题，只允许交易一次的情况。\n我们可以发现新的状态只跟相邻的状态有关，所以我们只需要记录两个状态就可以dp0和dp1。\n代码实现：\nclass Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { if(prices.empty()) return 0; int dp0 = 0, dp1 = INT_MIN; for(int i=0; i\u0026lt;prices.size(); i++){ dp0 = max(dp0, dp1 + prices[i]); dp1 = max(dp1, -prices[i]); //dp[i][0][0] = 0 因为没有交易次数所以收益一定为0 } return dp0; } };  我们再使用动态规划，考虑不限制交易次数的情况。其实只需要对上面的代码稍作修改即可。我们可以发现此时已经不需要记录k的状态，此时的状态转移方程应该为：\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])  代码实现：\nclass Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { if(prices.empty()) return 0; int dp0 = 0, dp1 = INT_MIN; for(int i=0; i\u0026lt;prices.size(); i++){ int tmp = dp0; dp0 = max(dp0, dp1 + prices[i]); dp1 = max(dp1, tmp - prices[i]); } return dp0; } };  ","id":8,"section":"posts","summary":"买卖股票问题有多种变体，在一些变体中需要考虑动态规划的思路才能够更好的解决。题目大意是给定一个数组，第i 个元素即股票在第i 天的价格，求解通过","tags":["Leetcode"],"title":"买卖股票问题","uri":"https://aimhector.github.io/2020/05/%E4%B9%B0%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/","year":"2020"},{"content":"关于多线程有两个重要问题:\n第一是主线程如何等地啊多个子线程完成初始化。\n第二是如何通知处于事件分发中的子线程有新的事件加入、删除、修改。\n","id":9,"section":"posts","summary":"关于多线程有两个重要问题: 第一是主线程如何等地啊多个子线程完成初始化。 第二是如何通知处于事件分发中的子线程有新的事件加入、删除、修改。","tags":["网络编程"],"title":"高性能web服务器（二）：多线程设计","uri":"https://aimhector.github.io/2020/05/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B03/","year":"2020"},{"content":" 在编写高性能web服务器之前，首先需要构建一个支持TCP的高性能网络编程框架，有了框架之后，再添加HTTP特性的支持就会容易很多。\n设计需求 需要满足如下三个需求：\n 采用reactor模型，可以灵活使用poll/epoll作为时间分发。 支持多线程，可以支持单线程的reactor模式，可以将套接字上的I/O事件分离到多个线程上。 封装读写对象到Buffer对象中。  设计思路 反应堆模式设计 event_loop\n是一个线程绑定的无限事件循环，一旦有事件发生，就会回调预先定义好的回调函数，完成事件的处理。\nchannel\n对于注册到event_loop上的对象，我们抽象成channel来表示。\nacceptor\nacceptor对象表示的是服务器监听器，acceptor对象最终会作为一个channel对象注册到event_loop上。\nevent_dispatcher\n对事件分发机制的一种抽象，可以基于poll或epoll。这里统一设置成一个结构体来抽象这个行为。\nchannel_map\n保存了描述字到channel的映射，这样就可以在事件发生时，根据事件类型对应的套接字快速找到chanel对象里的事件处理函数。\nI/O模型和多线程模型设计 I/O线程和多线程模型，主要解决event_loop的线程运行问题，以及事件分发和回调的线程执行问题。\ntherad_pool\n维护了sub_reactor的线程列表，给主reactor提供线程，当有新的连接建立时，可以从therad_pool里获取一个线程。\nevent_loop_thread\nBuffer和数据读写 进一步分析 概述 下图为event_loop的运行流程图。\n 当 event_loop_run 完成之后，线程进入循环，首先执行 dispatch 事件分发，一旦有事件发生，就会调用 channel_event_activate 函数，在这个函数中完成事件回调函数 eventReadcallback 和 eventWritecallback 的调用，最后再进行 event_loop_handle_pending_channel，用来修改当前监听的事件列表，完成这个部分之后，又进入了事件分发循环。\nevent_loop分析 先看一下 event_loop 的数据结构。在这个数据结构中，最重要的莫过于 event_dispatcher 对象了。你可以简单地把 event_dispatcher 理解为 poll 或者 epoll，它可以让我们的线程挂起，等待事件的发生。\nevent_loop 中还保留了几个跟多线程有关的对象，如 owner_thread_id 是保留了每个 event loop 的线程 ID，mutex 和 con 是用来进行线程同步的。\nstruct event_loop { int quit; const struct event_dispatcher *eventDispatcher; /** 对应的event_dispatcher的数据. */ void *event_dispatcher_data; struct channel_map *channelMap; int is_handle_pending; struct channel_element *pending_head; struct channel_element *pending_tail; pthread_t owner_thread_id; pthread_mutex_t mutex; pthread_cond_t cond; int socketPair[2]; char *thread_name; };  event_loop_run  event_loop 就是一个无限 while 循环，不断地在分发事件。\n/** * * 1.参数验证 * 2.调用dispatcher来进行事件分发,分发完回调事件处理函数 */ int event_loop_run(struct event_loop *eventLoop) { assert(eventLoop != NULL); struct event_dispatcher *dispatcher = eventLoop-\u0026gt;eventDispatcher; if (eventLoop-\u0026gt;owner_thread_id != pthread_self()) { exit(1); } yolanda_msgx(\u0026quot;event loop run, %s\u0026quot;, eventLoop-\u0026gt;thread_name); struct timeval timeval; timeval.tv_sec = 1; while (!eventLoop-\u0026gt;quit) { //block here to wait I/O event, and get active channels dispatcher-\u0026gt;dispatch(eventLoop, \u0026amp;timeval); //handle the pending channel event_loop_handle_pending_channel(eventLoop); } yolanda_msgx(\u0026quot;event loop end, %s\u0026quot;, eventLoop-\u0026gt;thread_name); return 0; }  在 event_loop 不退出的情况下，一直在循环，循环体中调用了 dispatcher 对象的 dispatch 方法来等待事件的发生。\nchannel 对象分析 channel 对象是用来和 event_dispather 进行交互的最主要的结构体，它抽象了事件分发。一个 channel 对应一个描述字，描述字上可以有 READ 可读事件，也可以有 WRITE 可写事件。channel 对象绑定了事件处理函数 event_read_callback 和 event_write_callback。\ntypedef int (*event_read_callback)(void *data); typedef int (*event_write_callback)(void *data); struct channel { int fd; int events; //表示event类型 event_read_callback eventReadCallback; event_write_callback eventWriteCallback; void *data; //callback data, 可能是event_loop，也可能是tcp_server或者tcp_connection };  channel_map 对象分析 event_dispatcher 在获得活动事件列表之后，需要通过文件描述字找到对应的 channel，从而回调 channel 上的事件处理函数 event_read_callback 和 event_write_callback，为此，设计了 channel_map 对象。\n/** * channel映射表, key为对应的socket描述字 */ struct channel_map { void **entries; /* The number of entries available in entries */ int nentries; };  ","id":10,"section":"posts","summary":"在编写高性能web服务器之前，首先需要构建一个支持TCP的高性能网络编程框架，有了框架之后，再添加HTTP特性的支持就会容易很多。 设计需求 需","tags":["网络编程"],"title":"高性能web服务器（一）：设计思路","uri":"https://aimhector.github.io/2020/05/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B02/","year":"2020"},{"content":"C++的编译链接  预处理 编译 汇编 链接  C++的编程范式 面向过程指的是顺序执行语句、子程序，把任务分解成若干个步骤去执行，最终达成目标。\n面向对象的核心思想是“抽象”和“封装”，将任务分解成一些低耦合的对象，这些对象互相通信协作来完成任务。更加强调对象之间的关系和接口。\n面向对象的范式包括class、public、private、virtual、this等关键字，还有构造函数、析构函数、友元函数等概念。\n泛型编程是自 STL（标准模板库）纳入到 C++ 标准以后才逐渐流行起来的新范式，核心思想是“一切皆为类型”，或者说是“参数化类型”“类型擦除”，使用模板而不是继承的方式来复用代码，所以运行效率更高，代码也更简洁。\n在 C++ 里，泛型的基础就是 template 关键字，然后是庞大而复杂的标准库，里面有各种泛型容器和算法，比如 vector、map、sort，等等。\n","id":11,"section":"posts","summary":"C++的编译链接 预处理 编译 汇编 链接 C++的编程范式 面向过程指的是顺序执行语句、子程序，把任务分解成若干个步骤去执行，最终达成目标。 面向对象的","tags":["C++"],"title":"C++生命周期与编程范式","uri":"https://aimhector.github.io/2020/05/c-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","year":"2020"},{"content":"题目描述：\n有一个二维矩阵 A 其中每个元素的值为 0 或 1 。\n移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。\n在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。\n返回尽可能高的分数。\n 示例：\n输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]] 输出：39  解释：\n转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]] 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39  思路：\n 首先判断第一列是否都为1，如果元素不为1，则反转相应的行。然后从第二列开始遍历，判断每一列1的个数是否超过总数的一半，如果不超过，则反转相应的列，同时将结果累加。\n代码：\nclass Solution { public: int matrixScore(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; A) { if(A.empty()) return 0; int cos = A.size(); int row = A[0].size(); for(int i=0; i\u0026lt;cos; i++){ if(A[i][0] == 0){ int dex=0; while(dex \u0026lt; row){ A[i][dex] ^= 1; //对元素进行异或运算，1^1 = 0 ; 0^1 = 1 dex++; } } } int sum = cos * pow(2, row - 1); //记录第一列的和 for(int i=1; i\u0026lt;row; i++){ int count = 0; for(int j=0; j\u0026lt;cos; j++){ if(A[j][i] == 1) count ++; } if(count \u0026lt;= cos/2) count = cos - count; // 判断1的个数是否超过总行数的一半 sum += count * pow(2, row - i - 1); //计算当前列的和并进行累加 } return sum; } };  ","id":12,"section":"posts","summary":"题目描述： 有一个二维矩阵 A 其中每个元素的值为 0 或 1 。 移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为","tags":["Leetcode"],"title":"861. 翻转矩阵后的得分","uri":"https://aimhector.github.io/2020/05/861/","year":"2020"},{"content":"题目描述：\n如果我们交换字符串 X 中的两个不同位置的字母，使得它和字符串 Y 相等，那么称 X 和 Y 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。\n例如，\u0026ldquo;tars\u0026rdquo; 和 \u0026ldquo;rats\u0026rdquo; 是相似的 (交换 0 与 2 的位置)； \u0026ldquo;rats\u0026rdquo; 和 \u0026ldquo;arts\u0026rdquo; 也是相似的，但是 \u0026ldquo;star\u0026rdquo; 不与 \u0026ldquo;tars\u0026rdquo;，\u0026ldquo;rats\u0026rdquo;，或 \u0026ldquo;arts\u0026rdquo; 相似。\n总之，它们通过相似性形成了两个关联组：{\u0026ldquo;tars\u0026rdquo;, \u0026ldquo;rats\u0026rdquo;, \u0026ldquo;arts\u0026rdquo;} 和 {\u0026ldquo;star\u0026rdquo;}。注意，\u0026ldquo;tars\u0026rdquo; 和 \u0026ldquo;arts\u0026rdquo; 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。\n我们给出了一个不包含重复的字符串列表 A。列表中的每个字符串都是 A 中其它所有字符串的一个字母异位词。请问 A 中有多少个相似字符串组？\n输入：[\u0026ldquo;tars\u0026rdquo;,\u0026ldquo;rats\u0026rdquo;,\u0026ldquo;arts\u0026rdquo;,\u0026ldquo;star\u0026rdquo;]\n输出：2\n思路：\nconst int maxn = 1e4+10; class Solution { public: vector\u0026lt;int\u0026gt; g[maxn]; bool solve(string \u0026amp;s1,string \u0026amp;s2){ int diff = 0; for(int i=0; i\u0026lt;s1.length(); i++){ if(s1[i] != s2[i]) diff++; if(diff\u0026gt;2) return false; } return true; } void dfs(int i,vector\u0026lt;int\u0026gt;\u0026amp;vis){ vis[i]=1; for(auto v:g[i]){ if(!vis[v]){ dfs(v,vis); } } } int numSimilarGroups(vector\u0026lt;string\u0026gt;\u0026amp; A) { int n = A.size(); for(int i=0; i\u0026lt;n; i++){ for(int j=1; j\u0026lt;n; j++){ if(solve(A[i],A[j])){ g[i].push_back(j); g[j].push_back(i); } } } int count = 0; vector\u0026lt;int\u0026gt; vis(n+1,0); for(int i =0; i\u0026lt;n; i++){ if(!vis[i]){ count++; dfs(i,vis); } } return count; } };  ","id":13,"section":"posts","summary":"题目描述： 如果我们交换字符串 X 中的两个不同位置的字母，使得它和字符串 Y 相等，那么称 X 和 Y 两个字符串相似。如果这两个字符串本身是相等的，那它们","tags":["Leetcode"],"title":"839. 相似字符串组","uri":"https://aimhector.github.io/2020/05/839/","year":"2020"},{"content":"阻塞 / 非阻塞 VS 同步 / 异步  第一种是阻塞 I/O。阻塞 I/O 发起的 read 请求，线程会被挂起，一直等到内核数据准备好，并把数据从内核区域拷贝到应用程序的缓冲区中，当拷贝过程完成，read 请求调用才返回。接下来，应用程序就可以对缓冲区的数据进行数据解析。\n 第二种是非阻塞 I/O。非阻塞的 read 请求在数据未准备好的情况下立即返回，应用程序可以不断轮询内核，直到数据准备好，内核将数据拷贝到应用程序缓冲，并完成这次 read 调用。注意，这里最后一次 read 调用，获取数据的过程，是一个同步的过程。这里的同步指的是内核区域的数据拷贝到缓存区这个过程。\n 每次让应用程序去轮询内核的 I/O 是否准备好，是一个不经济的做法，因为在轮询的过程中应用进程啥也不能干。于是，像 select、poll 这样的 I/O 多路复用技术就隆重登场了。通过 I/O 事件分发，当内核数据准备好时，再通知应用程序进行操作。这个做法大大改善了应用进程对 CPU 的利用率，在没有被通知的情况下，应用进程可以使用 CPU 做其他的事情。注意，这里 read 调用，获取数据的过程，也是一个同步的过程。\n 第一种阻塞 I/O 我想你已经比较了解了，在阻塞 I/O 的情况下，应用程序会被挂起，直到获取数据。第二种非阻塞 I/O 和第三种基于非阻塞 I/O 的多路复用技术，获取数据的操作不会被阻塞。\n 无论是第一种阻塞 I/O，还是第二种非阻塞 I/O，第三种基于非阻塞 I/O 的多路复用都是同步调用技术。为什么这么说呢？因为同步调用、异步调用的说法，是对于获取数据的过程而言的，前面几种最后获取数据的 read 操作调用，都是同步的，在 read 调用时，内核将数据从内核空间拷贝到应用程序空间，这个过程是在 read 函数中同步进行的，如果内核实现的拷贝效率很差，read 调用就会在这个同步过程中消耗比较长的时间。\n 而真正的异步调用则不用担心这个问题，我们接下来就来介绍第四种 I/O 技术，当我们发起 aio_read 之后，就立即返回，内核自动将数据从内核空间拷贝到应用程序空间，这个拷贝过程是异步的，内核自动完成的，和前面的同步操作不一样，应用程序并不需要主动发起拷贝动作。\n","id":14,"section":"posts","summary":"阻塞 / 非阻塞 VS 同步 / 异步 第一种是阻塞 I/O。阻塞 I/O 发起的 read 请求，线程会被挂起，一直等到内核数据准备好，并把数据从内核区域拷贝到应用程序的缓冲","tags":["网络编程"],"title":"网络IO模型","uri":"https://aimhector.github.io/2020/05/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B_01/","year":"2020"},{"content":"1.new 与 malloc\n new 是C++的操作符，malloc是C的标准库函数 new会调用构造函数，而malloc()不会 new返回指定类型的指针，而malloc()返回void* new会自动计算需要分配的空间，而malloc()需要手工计算字节数。 new可以被重载，而malloc()不能。  使用new时实际执行的三步操作：\n 调用::operator new 配置内存 调用Foo()构造函数构造对象并传入初始值 返回一个指向该对象的指针  2.内存溢出和内存泄漏 内存溢出，指的是系统不能再分配出你所需要的空间。\n内存泄漏，指的是没有释放掉已经不再使用的内存\n内存泄漏的类型\n 堆内存泄漏  程序运行中根据需要从堆内存中分配一块内存，并且没有释放掉。   系统资源泄漏  常见的内存溢出\n 内存分配未成功，却使用了它。 内存分配虽然成功，但是尚未初始化就引用它 。 内存分配成功并且已经初始化，但操作越过了内存的边界。 忘记了释放内存，造成内存泄露。  2.智能指针(将普通的指针封装为一个栈对象)\n智能指针可以防止忘记调用delete释放内存，以及多次释放同一个指针所造成的程序崩溃。实现了资源自动释放。\n unique_ptr  生命周期：从指针创建开始到离开作用域。 如果没有多线程共享资源，则使用unique_ptr   shared_ptr  智能指针是模版类，使用make_shared函数来初始化 ，不能将指针直接复制给一个智能指针 get函数获取原始指针 使用引用计数实现多个智能指针同时指向一个对象 拷贝和赋值，拷贝使得对象的引用计数加一，赋值使得引用计数减一，指向后来的对象。 循环引用，会导致堆内存无法正确释放导致内存泄漏。   weak_ptr  不控制所指对象的生命周期，指向一个由shared_ptr管理的对象 使用shared_ptr来初始化它 auto p = make_shared42 ; weak_ptrwp(p)//wp弱共享p,p的引用计数不变。 expired()观测引用计数，若为true则引用计数为0；lock(),获取一个可用的shared_ptr对象，从而操作资源，若引用计数为0则返回一个存储空指针的shared_ptr    内部实现\nhttps://blog.csdn.net/gammag/article/details/88655744\n3. 虚函数\n虚函数的作用 C++中的虚函数的作用主要是实现了多态的机制。基类定义虚函数，子类可以重写该函数；在派生类中对基类定义的虚函数进行重写时，需要在派生类中声明该方法为虚方法。\n当子类重新定义了父类的虚函数后，当父类的指针指向子类对象的地址时，[即B b; A a = \u0026amp;b;] 父类指针根据赋给它的不同子类指针，动态的调用子类的该函数，而不是父类的函数（如果不使用virtual方法，请看后面★*），且这样的函数调用发生在运行阶段，而不是发生在编译阶段，称为动态联编。而函数的重载可以认为是多态，只不过是静态的。注意，非虚函数静态联编，效率要比虚函数高，但是不具备动态联编能力。\n虚函数的实现机制\n虚函数表\n1、当类中存在虚函数里.则编译器会在编译期自动的给该类生成一个函数表，并在所有该类的对像中放入一个隐式变量vptr,该变量是一个指针变量，它的值指向那个类中的由编译器生成的虚函数表.\n2、每个类自己的虚函数入口都在这张表中维护，调用方法的时候会隐式的传入一个this指针，然后系统会根据this指针找到对应的vptr,进而找到对应的虚函数表，找到真正方法的地址，然后才去调用这个方法，这可以叫动态绑定。\n3、虚函数表存放重写的虚函数，当基类的指针指向派生类的对象时，调用虚函数时都会根据vptr来选择虚函数，而基类的虚函数在派生类里已经被改写或者说已经不存在了，所以也就只能调用派生类的虚函数版本了.\n实现机制\nhttps://www.cnblogs.com/malecrab/p/5572730.html\nhttps://www.cnblogs.com/yinbiao/p/11603618.html\nvptr问题\nhttps://www.cnblogs.com/yangguang-it/p/6547314.html\n析构函数可以是虚函数吗\n如果基类会被继承，则需要将析构函数设置为虚函数。\n基类指针可以指向派生类的对象（多态性），如果删除该指针delete[] p;就会调用该指针指向的派生类析构函数，而派生类的析构函数又会自动调用基类的析构函数，这样整个派生类的对象完全被释放。如果析构函数不被声明为虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类的析构函数，这样就会造成派生类对象析构不完全。所以，将析构函数声明为虚函数是十分必要的。\n构造函数可以调用虚函数\n构造函数是可以调用虚函数的，例子 https://paste.ubuntu.com/p/qwGZRNjj2m/\n总结：是进行静态绑定，首先构造父类构造函数，虚函数也调用父类的，然后调用子类构造函数，虚函数也调用子类的。\n纯虚函数和虚函数\n有纯虚函数的类为抽象类。 纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。\n在基类中实现纯虚函数的方法是在函数原型后加“=0” virtual void function()=0\n详情见：https://www.cnblogs.com/steven66/p/5013695.html。\n4.面向对象理解\n详情见：https://www.cnblogs.com/ycg0808/p/5479213.html。\n四大特征：继承、多态、封装、抽象。\n继承：子类继承父类的特征和行为。子类可以有父类的方法，属性（非private）。子类也可以对父类进行扩展，也可以重写父类的方法。缺点就是提高了代码之间的耦合。final可以修饰类，方法，属性。修饰的类不能继承，修饰的方法不能重写，修饰的属性不能修改。\n多态：多态就是不同类的对象，对同一消息做出不同响应就叫多态。\n封装：封装就是把过程和数据包围起来，对数据的访问只能通过特定的界面。能降低耦合性。\n抽象：分为过程抽象和数据抽象。\n详情见：https://www.cnblogs.com/msn-z/p/7802576.html。\n5.内存模型\n栈（局部变量，编译时分配） 堆（动态存储区）（new程序时分配） 静态存储区（所有的静态/全局变量） 数据区 代码区\nC分为4个区：堆，栈，静态全局变量区，常量区。 C++内存分为5个区：\n1：栈区（stack）-由编译器自动分配释放，存放函数参数值，局部变量等。其操作类似于数据机构中栈。\n2：堆区（heap）-一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中堆是两回事，分配方式类似于链表。\n3：全局区（静态区static）-全局变量和静态变量存取释放在一快，初始化全局变量和静态变量在一块区域。未初始化全局变量和未初始化静态变量在相邻另一块区域，程序结束后由系统释放。\n4：文字常量区（coment）-常量字符串就是放在这里。程序结束后由系统释放。\n5： 程序代码区（code）- 存放函数二进制代码 详情见：https://www.cnblogs.com/Stultz-Lee/p/6751522.html。\n5.常见设计模式\n详细链接\nhttps://blog.csdn.net/u010993820/article/details/80968933\n单例模式详解\nhttps://blog.csdn.net/zhanghuaichao/article/details/79459130\n6.inline\nC++ 用 inline 关键字较好地解决了函数调用开销的问题。\n增加了 inline 关键字的函数称为“内联函数”。内联函数和普通函数的区别在于：当编译器处理调用内联函数的语句时，不会将该语句编译成函数调用的指令，而是直接将整个函数体的代码插人调用语句处，就像整个函数体在调用处被重写了一遍一样。\n有了内联函数，就能像调用一个函数那样方便地重复使用一段代码，而不需要付出执行函数调用的额外开销。很显然，使用内联函数会使最终可执行程序的体积增加。以时间换取空间，或增加空间消耗来节省时间，这是计算机学科中常用的方法。\n内联函数中的代码应该只是很简单、执行很快的几条语句。若比较复杂则不会判为内联函数。\nhttp://c.biancheng.net/view/199.html\nSTL 源码内容 1.STL的vector底层扩容\nvector实际上就是一个动态数组，底层是一段连续的线性内存空间。使用三个迭代器表示（指针）\n当大小和容量相等时，vector就需要扩容，此时需要三个步骤：\n 弃用现在的内存空间，申请一个两倍（1.5倍）大小的新的内存空间。 将旧的内存空间中的数据写入 将旧内存空间释放  2.STL的map、set底层数据结构\n查询的时间复杂度为O(lgn);空间复杂度为O(n); 底层数据结构都为红黑树\n红黑树底层提供两种insert操作：insert_unique() /insert_equal()\n红黑树的实现：五个模版（key value keyofvalue compare alloc）\nset\n set/multiset元素的value和key合一：value就是key 不可以通过迭代器修改元素（set的iterator为红黑树的const 迭代器，从而避免通过迭代器改变元素） set的操作都转给底层的模版进行操作，从技术的角度来说，set是一种container adapter（容器适配器，类似queue）  map\n map中key不可以修改，value可以。value和key组成value 红黑树的selectlst（select first）获取key （gcc） 实现第一条：把value包装成pair，其中key设置为const 独特的operator[],如果key不存在，lower_bound()找到合适的位置，并创建一个key插入红黑树  3.容器hashtable\n  空间足够时，直接按照编号插入\n  空间不足时，编号取余（空间大小）\n  如果发生冲突则通过链表串起来，但是如果串联的个数大于buckets vector（篮子的数量）则进行散列（篮子变为两倍附近的素数，53-\u0026gt;97）\n  hashtable的实现：value、key、HashFcn（将放入的东西映射为编号）、ExtractKey（如何提取key）、EqualKey（定义key相等）\n  ","id":15,"section":"posts","summary":"1.new 与 malloc new 是C++的操作符，malloc是C的标准库函数 new会调用构造函数，而malloc()不会 new返回指定类型的指针，而malloc(","tags":["C++"],"title":"C++基础问题总结","uri":"https://aimhector.github.io/2020/04/c-/","year":"2020"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\n Create a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so:\n  {{ if or .Params.math .Site.Params.math }} {{ partial \u0026quot;math.html\u0026quot; . }} {{ end }}   To enable KaTex globally set the parameter math to true in a project's configuration To enable KaTex on a per page basis include the parameter math: true in content files.  Note: Use the online reference of Supported TeX Functions Examples Inline math: \\( \\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887… \\)\nBlock math:\n\\[ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } \\]\n","id":16,"section":"posts","summary":"\u003cp\u003eMathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\u003c/p\u003e","tags":null,"title":"Math Typesetting","uri":"https://aimhector.github.io/2019/03/math-typesetting/","year":"2019"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site’s configuration and then you can type emoji shorthand codes directly in content files; e.g.\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\n N.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n.emoji { font-family: Apple Color Emoji,Segoe UI Emoji,NotoColorEmoji,Segoe UI Symbol,Android Emoji,EmojiSymbols; }","id":17,"section":"posts","summary":"\u003cp\u003eEmoji can be enabled in a Hugo project in a number of ways.\u003c/p\u003e","tags":["emoji"],"title":"Emoji Support","uri":"https://aimhector.github.io/2019/03/emoji-support/","year":"2019"}],"tags":[{"title":"C++","uri":"https://aimhector.github.io/tags/c++/"},{"title":"emoji","uri":"https://aimhector.github.io/tags/emoji/"},{"title":"Leetcode","uri":"https://aimhector.github.io/tags/leetcode/"},{"title":"网络编程","uri":"https://aimhector.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]}